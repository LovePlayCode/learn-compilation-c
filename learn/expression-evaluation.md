# 表达式求值详解

本文档详细分析 `main.c` 中表达式 `-((1.2 + 3.4) / 5.6)` 的求值过程。

## 表达式结构

### 数学表达式

```
-((1.2 + 3.4) / 5.6)
```

### 抽象语法树 (AST)

```
              Negate (-)
                  │
              Divide (/)
              /         \
          Add (+)       5.6
          /     \
        1.2     3.4
```

### 后缀表达式 (逆波兰表示法)

```
1.2  3.4  +  5.6  /  -
```

这正是字节码的执行顺序！

---

## 字节码与表达式的对应关系

```
表达式:  -  (  (  1.2  +  3.4  )  /  5.6  )

字节码:  OP_CONSTANT 0    ; 加载 1.2
         OP_CONSTANT 1    ; 加载 3.4
         OP_ADD           ; 1.2 + 3.4
         OP_CONSTANT 2    ; 加载 5.6
         OP_DIVIDE        ; (1.2 + 3.4) / 5.6
         OP_NEGATE        ; -((1.2 + 3.4) / 5.6)
         OP_RETURN        ; 返回结果

对应关系:
┌────────────────────┬───────────────────┬──────────────────┐
│     表达式部分      │      字节码        │     栈变化        │
├────────────────────┼───────────────────┼──────────────────┤
│        1.2         │  OP_CONSTANT 0    │  [1.2]           │
│        3.4         │  OP_CONSTANT 1    │  [1.2, 3.4]      │
│    1.2 + 3.4       │  OP_ADD           │  [4.6]           │
│        5.6         │  OP_CONSTANT 2    │  [4.6, 5.6]      │
│  (1.2+3.4) / 5.6   │  OP_DIVIDE        │  [0.821...]      │
│  -((1.2+3.4)/5.6)  │  OP_NEGATE        │  [-0.821...]     │
│       返回         │  OP_RETURN        │  []              │
└────────────────────┴───────────────────┴──────────────────┘
```

---

## 逐步执行追踪

### 初始状态

```
字节码:  [CNST][0][CNST][1][ADD][CNST][2][DIV][NEG][RET]
          ▲
          ip

常量池:  [1.2, 3.4, 5.6]

栈:      空
```

### 第 1 步: OP_CONSTANT 0

```
操作:    读取 OP_CONSTANT
         读取操作数 0
         从常量池取 constants[0] = 1.2
         push(1.2)

字节码:  [CNST][0][CNST][1][ADD][CNST][2][DIV][NEG][RET]
                   ▲
                   ip

栈:      
         ┌───────┐
         │  1.2  │ ← top
         └───────┘
```

### 第 2 步: OP_CONSTANT 1

```
操作:    读取 OP_CONSTANT
         读取操作数 1
         从常量池取 constants[1] = 3.4
         push(3.4)

字节码:  [CNST][0][CNST][1][ADD][CNST][2][DIV][NEG][RET]
                            ▲
                            ip

栈:      
         ┌───────┐
         │  3.4  │ ← top
         ├───────┤
         │  1.2  │
         └───────┘
```

### 第 3 步: OP_ADD

```
操作:    读取 OP_ADD
         b = pop() → 3.4
         a = pop() → 1.2
         result = a + b = 1.2 + 3.4 = 4.6
         push(4.6)

字节码:  [CNST][0][CNST][1][ADD][CNST][2][DIV][NEG][RET]
                                 ▲
                                 ip

栈的变化:
         弹出 b        弹出 a        压入结果
         ┌───────┐    ┌───────┐    ┌───────┐
         │  3.4  │ →  │       │    │  4.6  │ ← top
         ├───────┤    ├───────┤    └───────┘
         │  1.2  │    │  1.2  │ → 
         └───────┘    └───────┘
```

### 第 4 步: OP_CONSTANT 2

```
操作:    读取 OP_CONSTANT
         读取操作数 2
         从常量池取 constants[2] = 5.6
         push(5.6)

字节码:  [CNST][0][CNST][1][ADD][CNST][2][DIV][NEG][RET]
                                        ▲
                                        ip

栈:      
         ┌───────┐
         │  5.6  │ ← top
         ├───────┤
         │  4.6  │
         └───────┘
```

### 第 5 步: OP_DIVIDE

```
操作:    读取 OP_DIVIDE
         b = pop() → 5.6
         a = pop() → 4.6
         result = a / b = 4.6 / 5.6 ≈ 0.8214285714
         push(0.8214285714)

字节码:  [CNST][0][CNST][1][ADD][CNST][2][DIV][NEG][RET]
                                            ▲
                                            ip

栈的变化:
         弹出 b        弹出 a        压入结果
         ┌───────┐    ┌───────┐    ┌────────────┐
         │  5.6  │ →  │       │    │ 0.821428.. │ ← top
         ├───────┤    ├───────┤    └────────────┘
         │  4.6  │    │  4.6  │ → 
         └───────┘    └───────┘

计算:    4.6 / 5.6 = 0.8214285714285714
```

### 第 6 步: OP_NEGATE

```
操作:    读取 OP_NEGATE
         value = pop() → 0.8214285714
         push(-value) → push(-0.8214285714)

字节码:  [CNST][0][CNST][1][ADD][CNST][2][DIV][NEG][RET]
                                                ▲
                                                ip

栈的变化:
         弹出          压入
         ┌────────────┐    ┌─────────────┐
         │ 0.821428.. │ →  │ -0.821428.. │ ← top
         └────────────┘    └─────────────┘

计算:    -(0.8214285714) = -0.8214285714
```

### 第 7 步: OP_RETURN

```
操作:    读取 OP_RETURN
         result = pop() → -0.8214285714
         printValue(result)
         输出: -0.8214285714
         return INTERPRET_OK

字节码:  [CNST][0][CNST][1][ADD][CNST][2][DIV][NEG][RET]
                                                    ▲
                                                    ip (结束)

栈:      空

输出:    -0.821428571428571
```

---

## 栈操作总结表

| 步骤 | 指令 | 读取 | 弹出 | 压入 | 栈内容 |
|------|------|------|------|------|--------|
| 1 | OP_CONSTANT | 0 | - | 1.2 | [1.2] |
| 2 | OP_CONSTANT | 1 | - | 3.4 | [1.2, 3.4] |
| 3 | OP_ADD | - | 3.4, 1.2 | 4.6 | [4.6] |
| 4 | OP_CONSTANT | 2 | - | 5.6 | [4.6, 5.6] |
| 5 | OP_DIVIDE | - | 5.6, 4.6 | 0.821... | [0.821...] |
| 6 | OP_NEGATE | - | 0.821... | -0.821... | [-0.821...] |
| 7 | OP_RETURN | - | -0.821... | - | [] |

---

## 为什么用栈式虚拟机？

### 优点

1. **实现简单** - 不需要寄存器分配算法
2. **代码紧凑** - 操作数隐含在栈中，不需要显式指定
3. **表达式求值自然** - 后缀表达式直接对应执行顺序

### 缺点

1. **更多内存访问** - 频繁的 push/pop 操作
2. **不能直接利用 CPU 寄存器** - 性能较寄存器式 VM 低

### 对比: 寄存器式虚拟机

如果用寄存器式虚拟机，同样的表达式可能是:

```
LOAD  R0, 1.2        ; R0 = 1.2
LOAD  R1, 3.4        ; R1 = 3.4
ADD   R0, R0, R1     ; R0 = R0 + R1 = 4.6
LOAD  R1, 5.6        ; R1 = 5.6
DIV   R0, R0, R1     ; R0 = R0 / R1 = 0.821...
NEG   R0, R0         ; R0 = -R0 = -0.821...
RET   R0             ; 返回 R0
```

---

## 扩展: 如何处理更复杂的表达式？

### 示例: `(a + b) * (c - d)`

```
字节码序列:
    OP_CONSTANT a    ; 压入 a
    OP_CONSTANT b    ; 压入 b
    OP_ADD           ; 弹出 a,b，压入 (a+b)
    OP_CONSTANT c    ; 压入 c
    OP_CONSTANT d    ; 压入 d
    OP_SUBTRACT      ; 弹出 c,d，压入 (c-d)
    OP_MULTIPLY      ; 弹出 (a+b),(c-d)，压入结果

栈的最大深度: 3
    [a+b, c, d] 在执行 OP_SUBTRACT 前
```

### 编译器如何生成这样的字节码？

使用 **递归下降解析** 配合 **Pratt 解析器**:

1. 解析表达式树
2. 后序遍历树（左子树 → 右子树 → 根节点）
3. 每个节点生成对应的字节码

这正是编译原理中将中缀表达式转换为后缀表达式的过程！
